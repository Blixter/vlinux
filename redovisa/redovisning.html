<!doctype html>
<html lang="sv">

<head>
    <meta charset="utf-8">
    <title>Redovisning av kursmoment i kursen vlinux</title>
    <link rel="stylesheet" href="style/style.css">
</head>

<body>



    <header>
        <nav class="navbar">
            <a href="me.html">Me</a>
            <a href="redovisning.html">Redovisning</a>
            <a href="om.html">Om</a>
        </nav>
    </header>



    <article>

        <header class="redovisning">
            <h1>Redovisning av kursmoment i kursen vlinux</h1>
        </header>

        <nav class="navbar2">
            <a href="#kmom01">Kmom01</a>
            <a href="#kmom02">Kmom02</a>
            <a href="#kmom03">Kmom03</a>
            <a href="#kmom04">Kmom04</a>
            <a href="#kmom05">Kmom05</a>
            <a href="#kmom06">Kmom06</a>
            <a href="#kmom10">Kmom10</a>
        </nav>

        <section>
            <h2><a name="kmom01">Kmom01</a></h2>
            <b>
                <p>Är du sedan tidigare bekant med Unix, Linux, Debian och/eller
                    terminalen?</p>
            </b>
            <p>Sedan jag började studera på BTH så har jag gått över till Linux
                på alla mina datorer. Jag köpte mig även
                en Raspberry Pi redan i slutet på första terminen för att komma
                igång med Linux och server.
                Så jag är rätt så bekant kan man säga, även om jag fortfarade
                har mycket att lära mig.</p>
            <b>
                <p>Hur känns det med Unix-kommandon på terminalen, är det udda
                    eller bekvämt?</p>
            </b>
            <p>Jag gillar att sitta i terminalen och arbeta så det känns riktigt
                bra! Det är så här jag vill jobba i
                framtiden.</p>
            <b>
                <p>Valde du att köra standard med VirtualBox och Debian eller
                    hur gjorde du?</p>
            </b>
            <p>Jag har en Raspbian server sidan tidigare och jag gjorde först
                uppgifterna på den. Men sedan fick jag
                reda på att det är bäst att installera VirtualBox med Debian,
                vilket jag gjorde.
                Följde Kenneths installations-guide, fungerade bra!</p>
            <b>
                <p>Hur kändes det att jobba med VirtualBox och ser du fördelar
                    med det arbetssättet?</p>
            </b>
            <p>I början kändes det rätt onödigt när jag redan hade en server.
                Men jag inser nu att det är ett mycket smidigt
                sätt att skapa nya miljöer att jobba inom som är lätta att
                återställa om något skulle gå fel.</p>

            <b>
                <p>Installerade du Guest Additions?</p>
            </b>
            <p>Ja, det gjorde jag. Det var inte jättelätt att få det att
                fungera. Jag följde guiden men det gick
                inte. Det fanns inget att mounta. Däremot så laddade jag
                istället ner Guest Additions och mountade det
                själv till VirtualBox och då kunde min server hitta "cd-skivan".
                Känns viktigt att kunna kopiera mellan mitt operativsystem och
                den virtuellaboxen.</p>

            <b>
                <p>Var det något som krånglade eller tog extra mycket tid?</p>
            </b>
            <p>Nej allting fungerade bra, mycket på grund av att jag suttit
                mycket i Linux under året som har gått.</p>

        </section>

        <section>
            <h2><a name="kmom02">Kmom02</a></h2>
            <b>
                <p>Hur känns konceptet med Apache name-based Virtual Hosts?
                    Känner du igen det sedan tidigare?</p>
            </b>
            <p>Det var intressant att kunna skapa flera webbplatser på samma
                Apache-server. Jag visste inte att den möjligheten fanns
                tidigare, detta öppnar upp nya möjligheter för framtida projekt.
                Det var simpelt att sätta upp nya virtuella hostar.</p>

            <b>
                <p>Det blir allt fler kommandon i terminalen, hur känns det med
                    terminalen och dess kommandon?</p>
            </b>
            <p>Jag tycker om att jobba i terminal och känner mig mer bekväm för
                varje gång jag gör det. Kommandon som i början av min utbildning
                var krångliga att komma ihåg och förstå är självklara idag.
                Jag vill fortsätta att jobba i terminal i framtiden och vill
                bara lära mig mer.</p>

            <b>
                <p>Gick det bra med ssh-nycklar och rsync över ssh?</p>
            </b>
            <p>Ja, jag följde guiderna noga och då fungerade det precis som det
                skulle. Jag hade redan ssh-nycklar sedan tidigare och kunde
                återanvända dem istället för att skapa nya.</p>

            <b>
                <p>Hur kändes det att jobba med tmux?</p>
            </b>
            <p>Tmux började jag använde redan i slutet av första terminen. Det
                är smidigt att kunna komma tillbaka där man var istället för att
                "börja om", främst när man har en server man kopplar upp sig
                till.</p>

            <b>
                <p>Reflektera över hur du känner inför Unix som operativsystem
                    så här långt?</p>
            </b>
            <p>Eftersom att jag har gått över till Linux på mina datorer här
                hemma, samt har en egen liten server här hemma så är jag van vid
                Unix. Jag gillar att arbeta i terminalen som sagt och vill
                fortsätta lära mig mer.
                Den största skillnaden mellan Windows (som jag brukade använda
                tidigare) och Unix-baserade operativsystem är
                användarvänligheten. Det är alltså lättare att förstå Windows,
                det är lite krångligare när man behöver skriva kommandon i
                terminalen för att göra relativt simpla saker som det är i
                Linux. Men när man väl lär sig Unix så är det nästan smidigare
                att fixa det mesta direkt i terminalen, roligare om inte annat!
            </p>

        </section>

        <section>
            <h2><a name="kmom03">Kmom03</a></h2>
            <b>
                <p>Är detta din första bekantskap med skriptprogrammering i
                    Bash?</p>
            </b>
            <p>Ja, det är första gången som jag gör skript i Bash. Jag har
                tidigare skrivit skript i Python och JavaScript (Node) och
                därifrån ser jag likheter.</p>

            <b>
                <p>Berätta om din uppfattning om Bash som programmeringsmiljö,
                    relatera till andra programspråk du kan.</p>
            </b>
            <p>Som jag nämnde tidigare påminner syntaxen om Python. Samtidigt så
                anser jag at Bash är det programeringsspråk som är mest
                annorlunda av de språk jag lärt mig hittills. Det känns som ett
                äldre
                programmeringsspråk. Blir inte lika tydligt att läsa som till
                exempel Python. </p>

            <b>
                <p>Vilka möjligheter/utmaningar ser du med denna typen av
                    skriptprogrammering?</p>
            </b>
            <p>Jag ser rätt många möjligheter eftersom bash är en del av unix
                och
                det fungerar att skriva vanliga kommandon som jag är van att
                skriva i terminalen.
                Därför kan man automatisera en del kommandon för att helt enkelt
                spara tid.
                Det går att skapa skript som gör mina arbetsuppgifter enklare.
                Skripten man skapar går sedan att köra direkt i terminalen
                vilket gör det oerhört smidigt.
            </p>

            <b>
                <p>Var det något som var extra svårt eller utmanande i
                    uppgifterna?</p>
            </b>
            <p>Det var lite klurigt med labben innan man lärde sig syntaxen
                och hur de olika kommandona fungerade.
                När jag väl lärde mig hur jag skulle tänka så gick det rätt
                fort. Likadant med att skapa skriptprogrammet, i början fastnade
                jag med hur man skickar med argument på rätt sätt, men när jag
                väl kom på det så gick det fort.
            </p>

            <b>
                <p>Har du arbetat med Docker innan?</p>
            </b>
            <p>Nej, docker är verkligen helt nytt för mig. Jag har knappt hört
                talas om ordet innan.
                Jag inser vilket bra verktyg det är för att skapa applikationer
                som sedan fungerar på samma sett oavsett vilket
                operativsystem/miljö det
                körs på.
            </p>

            <b>
                <p>Anser du att det är någon fördel/nackdel med Docker om du
                    jämför med VirtualBox?</p>
            </b>
            <p>Fördelerna är många. VirtualBox kräver mycket resurser av datorn,
                tar mycket plats och tar lång tid för att starta. Docker
                körs ovanpå det operativsystem datorn har, delar därför på
                resurserna, vilket innebär att Docker tar mindre plats och inte
                kräver lika mycket från datorn. Däremot har jag förstått att
                Docker inte är
                lika säkert.
            </p>

        </section>

        <section>
            <h2><a name="kmom04">Kmom04</a></h2>
            <b>
                <p>Vilken väg valde du för servern?</p>
            </b>
            <p>Jag valde att göra en server i Python med hjälp av Flask. Guiden
                var till stor hjälp och det gick smärtfritt tack vara den.
                Jag valde att dela upp de olika routsen i olika template-filer
                med
                lite HTML-kod för att strukturera upp data för de olika
                routsen.
                Jag insåg senare när jag började med klienten att jag kanske
                inte skulle ha lagt in HTML-kod eftersom det blev svårare att
                tyda datan som man fick tillbaka via curl.
            </p>
            <b>
                <p>Hur kommer det sig att du valde det?</p>
            </b>
            <p>Först och främst så är Python ett av mina favoritspråk, önskar
                att vi hade ännu mer av det språket i programmet.
                Det var ett tag sen jag använde Python nu och kunde inte motstå
                nu när tillfället fanns. Det var roligt att få programmera i
                Python igen.
                Jag märkte dock att jag hade glömt bort en hel del, men det
                löste jag med lite googlande.
            </p>
            <b>
                <p>Gick det bra med Docker?</p>
            </b>
            <p>Docker fungerade klockrent tycker jag. Det var i stort sett bara
                att
                följa guiden så fungerade det.
                Det enda som jag fastnade lite på var just den delen med att vi
                skulle läsa in mappen med json-filen som en volym.
                Tog ett tag innan jag förstod hur jag skulle göra detta. Det
                slutade upp så här: <code>docker run --rm -p 5000:5000 -v
                $(pwd)/data:/server/data/ blixter/python:latest
                </code> Det känns lite långt att behöva skriva det varje gång
                man
                skall köra igång Docker, kan jag tycka. Kanske läge att göra att
                bash-script för det ändamålet?
            </p>
            <b>
                <p>Hänger du med på koncepten kring klient och server?</p>
            </b>
            <p>Ja, det måste jag ändå säga att jag gör. Jag har en klient som
                läser in data från servern, och tar vara på den datan på något
                sätt. Det är servern som har datan och skickar den till
                användaren vid förfrågan.</p>
            <b>
                <p>Strukturerade du Bash-scriptet annorlunda jämfört med förra
                    kursmomentet?</p>
            </b>
            <p>Strukturen är den samma, däremot blev det lite ändringar eftersom
                alla kommandon skulle kunna skriva till en lokalfil. Det löste
                jag genom att när funktionen för varje kommando körs, så sparas
                alla inkommande argument i en array. Jag loopar sedan igenom den
                arrayen för att se om '-s' eller '--save' finns med. Om det
                finns med i arrayen, så körs ett curl-kommando där '-o
                saved.data' finns med.</p>
        </section>

        <section>
            <h2><a name="kmom05">Kmom05</a></h2>

            <b>
                <p>Hur kändes det att skriva ett litet större bash-skript? Var det något som var mer eller mindre
                    utmanande och tidskrävande?</p>
            </b>
            <p>Bash-skriptet i sig var relativt lätt att göra. Framför allt eftersom vi redan har en mall att gå efter
                från tidigare veckor.
                Jag försökte få en bra struktur på det med kommentarer som förklarade vad de olika funktionerna gjorde.
                Men det blir väldigt mycket kod och kan lätt bli rörigt.
                Så det är framför allt den biten som kan vara utmanande, att skriva en snyggare kod.
                Jag kan säkert lyfta ut mycket kod och placera i funktioner som kan återanvändas istället. Skall jobba
                mer med det i fortsättningen.
            </p>
            <b>
                <p>Kikade du på källkoden till maze-servern? Har du några reflektioner kring den?</p>
            </b>
            <p>Ja jag kollade lite fort på källkoden. Det är ett API som är kodat i Vanilla Javascript. Vilket är
                intressant, eftersom man oftast laddar ner massa externa paket för sådant här, men det går faktiskt att
                göra i bara Javascript.
                För att det skall fungera på server-sidan så är det node som kör webbservern. Jag hade förmodligen gjort
                ett API i express, men som sagt intressant att se alternativ till det. Det var en tydlig och bra
                dokumentation till också.
            </p>
            <b>
                <p>Gjorde du nåt speciellt i din mazerunner som du vill lyfta fram?</p>
            </b>
            <p>Jag jobbade en del med felhantering, det skall till exempel inte gå att skicka en request till servern
                att användaren vill gå en riktning som inte fungerar.
                Det löste jag genom att skapa en funktion som körs innan något skickas iväg till servern. Den funktionen
                kollar om
                den väg användaren har valt faktiskt är giltlig.
                Först görs det en koll så det verkligen är en av strängarna "west", "east", "north" eller "south" som
                skickas med. Om inte så sätts en variabel till false och användaren får ett felmeddelande att
                den vägen inte är möjlig att gå till.
                Om användaren har valt en väg av de fyra giltliga strängarna fast vägen inte är möjlig att gå till just
                nu så sätts samma
                variabel till false och användaren möts av samma felmeddelande. På så vis skickas bara giltliga värden
                till webservern.
            </p>

        </section>

        <section>
            <h2><a name="kmom06">Kmom06</a></h2>

            <b>
                <p>Kan du se fördelar/nackdelar med Compose?</p>
            </b>
            <p>En stor fördel är att man kan starta sin container med ett simpelt kommando. Jag slipper köra ett stort
                run
                kommando varje gång jag vill köra min container.
                Likadant att jag kan stänga ner mina containrar på ett smidigt sätt. Nackdelen är väl egentligen bara
                att det blir ytterligare en fil att hålla koll på med sin egen syntax.
            </p>
            <b>
                <p>Hur väl har du fått ordning på begreppen kring klient och server?</p>
            </b>
            <p>Den delen tycker jag sitter bra nu, efter att ha jobbigt med det mycket hela hösten, i både denna kurs
                samt Jsramverk. Klienten läser in data från servern,
                och tar vara på den datan på något
                sätt. Servern har hand om datan och skickar den till
                klienten vid förfrågan.</p>
            <b>
                <p>Känner du dig bekväm med Docker överlag?</p>
            </b>
            <p>Så bekväm man kan känna sig efter denna kort tid med Docker. Men bekväm skulle jag inte säga.
                Behöver jobba mer med det först. Däremot så hade jag aldrig hört talas om Docker för några veckor
                sedan, så jag har verkligen lärt mig mycket dessa veckor.
            </p>
            <b>
                <p>Kommer du använda Docker utanför kursens ramar?</p>
            </b>
            <p>Om det är så att jag skapar en applikation som jag vill testa i en andra miljöer än de jag sitter i, så
                kommer jag absolut använda mig av Docker.
                Kan se mig själv använda Docker när jag börjar jobba med utveckling och vill testa i en miljö som
                efterliknar produktionsmiljön. </p>
            <b>
                <p>Gjorde du någon uppdatering av Mazerunnerns struktur?</p>
            </b>
            <p>Strukturen är i stort sett den samma. Jag la in en ny funktion `app-loop`, som sköter loopen av spelet.
                Sedan återanvänder jag
                funktioner som jag tidigare skapat. Jag tog bort lite utskriftstext från några av funktionerna, samt la
                till några nya globala variabler.</p>
            <b>
                <p>Vad tycker du om regex så här långt?</p>
            </b>
            <p>Vissa av uppgifterna i labben tog oerhört mycket tid. Det tog en bra stund innan jag
                kom in i hur jag skulle tänka. Det som framför allt var jobbigt i denna
                uppgift var att de internetverktyg som vi blev tipsade om inte riktigt stämmer överens med `sed`. Så det
                slutade med att jag försökte skriva regexen direkt i `sed`.
                Jag känner dock att jag har fått en förståelse för regex, vilket är viktigt då man använder det rätt så
                ofta
                vid olika valideringsformulär.
            </p>



        </section>

        <section>
            <h2><a name="kmom10">Kmom07-10</a></h2>
            <b>
                <p>Krav 1 Regex för att konvertera loggfil till JSON</p>
            </b>
            <p>Jag började att kopiera in loggen i onlineverktyget `Regex101`.
                Där jobbade jag igenom allt som man behövde få ut. Jag gjorde IP-numret till en grupp och URL till
                en grupp.</p>

            <p>När jag hade fått ut allt i olika grupper så jobbade jag med att föra över regexen till `sed`. Först
                blev det ett väldigt långt kommando, därför valde jag att dela upp kommandot i olika variabler.
                Regex-pattern för varje grupp fick sin egen variabel. Även formateringen för varje del i JSON-filen fick
                en egen variabel. Jag tog alltså ut de olika grupperna och gjorde resultatet till en JSON-fil.</p>

            <p>Jag skrev ut en opening-bracket `[` innan regex-resultatet. Sedan använder jag sed för att ändra om i
                JSON-filen.
                <code>sed -i '$ s/.$/\n]/</code>
                Med hjälp av det kommandot tar jag bort det sista kommatecknet och
                ersätter med en radbrytning och en closing bracket `]`. På så vis blir det ett giltligt JSON-format.</p>
            <b>
                <p>Krav 2 Server för att servera loggen</p>
            </b>
            <p>Jag valde att göra en server i Express.
                Jag skapade en array för route-listan, där varje element är ett objekt som har egenskaperna (properties)
                route och result.
                Det är innehållet i den som visas på index-sidan alltså '/'.</p>

            <p>Jag läser in JSON-filen som skapades av mitt log2json-skript.</p>

            <p>Innan jag gjorde krav 5, så gjorde jag en if-sats som helt enkelt kollade om värdet ip eller url fanns i
                query-strängen.
                Den loopade igenom hela JSON-filen och om värdet på ip eller url var den samma som värdet
                på inkommande query, så infogade jag objektet till en array med sökresultatet.
                Den array gjorde jag sedan om till JSON och returnerade. Om query-strängen var tom så returnerade den
                hela JSON-filen. Det blev inte speciellt dynamiskt så därför valde jag att göra om hela funktionaliteten
                för krav 5.</p>

            <p>Överst har jag flera olika hjälp-funktioner som gör det mesta av jobbet för sök-funktionen. Den
                funktionen som jag jobbade mest med och som var viktigast är
                `checkAllTrue`. Den tar emot två argument, en siffra som representerar index och en array där datan från
                query-strängen skall finnas.</p>

            <p>Det som händer när man gör en GET-request till `/data` är att det först görs en koll om det finns
                inkommande
                data i query-strängen.
                Om det finns, så loopar den igenom alla inkommande egenskaper (properties) och om de matchar de giltliga
                egenskaperna som går
                att
                söka på läggs dem in som objekt i en ny array `propArray`. Giltliga egenskaper är ["ip", "day", "month",
                "time", "url"].</p>

            <p>Sedan görs det en for-loop på längden av json-filen. Som loopar igenom json-arrayen där varje element
                representerar ett json-objekt. Nu görs det en koll så att alla värden i `propArray`
                matchar varje värde i json-filen, under samma egenskap (property). Om de matchar så läggs
                elementet till en ny array (jsonObject), som
                till sist returneras.</p>

            <p>Checkprop-funktionen kollar vilken den nuvarande egenskapen är (ip, day, time, month eller url) och den
                returnerar olika jämförelser beroende på vilken egenskap den hittar.
                Om det till exempel är 'time' så kollar den längden på sök-strängen. Detta gör den för att alltid
                jämföra med rätt siffror.
                Om användaren till exempel söker på 14 så skall den bara jämföra med de första 2 siffrorna och inte de
                sista fyra siffrorna. (14:00:00).</p>

            <p>I början gjorde jag en if-sats som täckte kravets alla olika fall. Men det blev väldigt mycket kod och
                jag
                ville att man skulle kunna söka på hur många egenskaper man ville i vilken kombination som helst. När
                jag kom fram till min lösning blev jag först förvånad över hur långt jag har kommit i min programmering
                sedan jag började för drygt ett år sedan. Sedan kändes det oerhört skönt att kunna skapa en sådan
                dynamisk kod.
            </p>
            <p>För att starta servern körs kommandot:
            <code>docker-compose up -d server</code></p>
            <b>
                <p>Krav 3 Bashscript för att testa servern</p>
            </b>
            <p>Jag återanvände mycket från tidigare bash-skript i kursen. Framför allt så håller jag samma struktur på
                scriptet.
                De olika kommandon som finns är:
                <pre>
url                 Få ut url:en för att se servern i webbläsaren.
view                Få ut all data i json-filen.
view url url-adress Få ut all data där url matchar söksträngen.
view ip ip-adress   Få ut all data där ip matchar söksträngen.
view month månad    Få ut all data där månad matchar söksträngen.
view day dag        Få ut all data där dag matchar söksträngen.
view time tid       Få ut all data där tid matchar söksträngen.
use server          Ändra server till given server.


--help, -h          Visar menyn.
--version, -h       Visar version.
--count, -c         Visar antal rader som matchar.
</pre>

                Det går att kombinera de olika söksträngarna hur man vill.</p>
            <p>
                Funktionen <b>app-url</b> returnerar den adress som det går att nå servern via webbläsaren.
            </p>
            <p>
                Funktionen <b>app-view</b> är den som returnerar all data från json-filen. Om man inte skickar in något
                argument så returneras all data.
                Skickas det in argument så tar den varje argument och loopar igenom och lägger till i query-strängen som
                sedan curlas för att få fram datan.
            </p>
            <p>Funktionen <b>app-view-count</b> gör samma sak som app-view men den kör detta kommando efter varje curl:
                <code>| jq '. | length</code>
                På så vis får jag fram antal rader.</p>
            <p>Funktionen <b>app-use</b> ändrar den nuvarande servern till det argumentet som skickas in.
                Detta genom att skriva argumentet till en fil, denna fil läses sedan in och sätter den globala variabeln
                SERVER när skriptet körs.</p>
            <p>Även här är det alltså möjligt att söka på alla olika egenskaper, som kan kombineras hur man vill genom
                att
                skriva t.ex.
                <code>./bthloggen.bash view url dbwebb ip 3.227 month Aug day 17 time 06:53</code>
                Som resulterar i:
                <pre>
[
    {
        "ip": "3.227.89.252",
        "day": "17",
        "month": "Aug",
        "time": "06:53:03",
        "url": "https://dbwebb.se"
    }
]
</pre>
            </p>
            <p>För att köra klienten körs kommandot:
                <code>docker-compose run client</code></p>
            <b>
                <p>Krav 4: Webbklient (optionell)</p>
            </b>
            <p>Jag har gjort en webbsida som kan visa upp serverns funktionalitet. Jag valde att skapa webbplatsen i
                Flask.
                Uppe i navbaren hittar man 'Search' som tar användaren till en undersida där man kan söka i loggen. Det
                går att söka på allt precis som i bash-klienten.</p>

            <p>Jag får tag i JSON-datan genom att köra:
                <code>response = requests.get('http://server:1337/data')</code>
                För att sedan göra om svaret till JSON gör jag bara response.json().

                Jag skickar JSON-svaret till templaten result.html. I den template-filen ritar jag upp JSON-svaret i en
                tabell.</p>
            <p>I template-filen search finns det ett formulär där man väljer vad man skall söka på. Vissa av värdena
                har jag gjort så att det bara kan går att fylla i dem på ett visst sätt med hjälp av regex. Till
                exempel:
                <code>
                pattern="[A-Z][a-z]{2}"
                </code>
                Här ovanför ser ni månads-fältet, där det bara går att fylla i tre bokstäver, där den första bokstan är
                stor och de
                resterande är små.
            </p>
            <p>Formuläret skickas sedan till search-routen via POST. Där görs det alltid en koll om det kommer en
                ingående
                POST-method.
                I sådana fall tar den hand om den postade datan genom att flytta datan till en dict. Sedan loopas dicten
                igenom och görs om till en querysträng så här:
                <pre>
data = request.form.to_dict()
for key in data:
    if data[key]:
        query += key + "=" + data[key] + "&"
                 </pre>
            </p>
            <p>
                Det görs sedan en förfrågan till servern med query-strängen och svaret ritas ut på samma sätt som jag
                förklarade tidigare.
            </p>

            <p>För att styra layouten av hemsidan har jag använt Bootstrap 4, som är ett verktyg jag har använt mer och
                mer för att främst använda grid.
                Tycker det är väldigt smidigt då man automatiskt får en responsiv sida.</p>
            <p>Jag hade problem med valideringen av min flask-applikation. Jag använder mig av template filer. Där jag
                öppnar element i headern som jag sedan stänger i min footer.
                Valideringsprogrammet verkar inte kunna se detta och klagar på att jag inte stänger taggarna på korrekt
                sätt. Därför går min webbklient inte igenom valideringen.
            </p>
            <p>För att köra webbklienten körs kommandot:
                <code>docker-compose up -d webclient</code></p>
            <b>
                <p>Krav 5: Mer data (optionell)</p>
            </b>
            <p>Eftersom basen redan fanns så var det bara att uttöka mitt regex-pattern. Det enda "problemet" var
                att koden blev så lång i mitt log2json.bash-skript.
                Jag valde därför att flytta ut pattern för varje grupp i en egen variabel.</p>
            <p>
                <pre>
# Pattern for getting the ip-adresses.
IP='([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})'

# Pattern for getting the URLs.
URL='((http|HTTP|https|HTTPS)\:\/\/[a-zA-z.]+)'

# Pattern for getting the day.
DAY='([0-9]{1,2})'

# Pattern for getting the month.
MONTH='([A-Za-z]{3})'

# Pattern for getting the time.
TIME='([0-9:]{8})'
                </pre>
            </p>

            <p>
                Som jag sedan kunde använda i mitt sed-kommando, genom att använda dubbelsnuttar så här:
                <code>'^'"$IP"'.*\['"$DAY"'\/'"$MONTH"''\</code>
                Det blev renare kod om jag dubbelsnuttade hela kommandot, får då behövde jag inte dubbelsnutta
                variablerna:
                <code>"^$IP.*\[$DAY\/$MONTH"\</code>
                Däremot så gick koden inte igenom valideringen när jag hade den formateringen, så jag fick därför gå
                över till den övre formateringen.
                Jag valde även att göra om ersättningsdelen i mitt Sed-kommando till variabler, där jag delade upp varje
                grupp i sin egen formateringsvariabel på detta vis:
                <pre>
# Format to JSON style
IP_FORMAT='\n\t{\n\t\t\"ip\": \"\1\",'

# Format to JSON style
DAY_FORMAT='\n\t\t\"day\": \"\2\",'

# Format to JSON style
MONTH_FORMAT='\n\t\t\"month\": \"\3\",'

# Format to JSON style
TIME_FORMAT='\n\t\t\"time\": \"\4\",'

# Format to JSON style
URL_FORMAT='\n\t\t\"url\": \"\5\"'
                </pre>

                Det blev ändå en väldigt lång kommandorad och jag ville därför skriva kommandot över flera rader.
                Det lyckades jag med genom att använda '\' i slutet av varje rad.
            </p>

            <p>Hur jag löste servern, klienten och webbklienten för krav-5 skrev jag under respektive krav.</p>
            <b>
                    <p>Skriv ett allmänt stycke om hur projektet gick att genomföra.</p>
                </b>
                <p>
                    Projektet gick förvånansvärt lätt att genomföra. Framför allt för att vi redan gjort i stort sett allt som krävdes i tidigare kursmoment.
                    Jag började därför med att gå tillbaka och se hur jag hade gjort tidigare och försökte självklart skriva om koden på ett bättre sätt. Försöker alltid få koden så kort och strukturerad som möjligt.
                    Projektet tog cirka en vecka att göra så storleksmässigt var det precis lagom. Jag har haft lite svårt att se mig själv när jag skulle behöva använda Docker.
                    Detta projekt gjorde att jag fick upp ögonen ännu mer för användsområdet för Docker. Då vi kan skapa en server som har två klienter kopplade till sig som smidigt startas med korta kommandon och alla resurser som behövs följer med.
                    Perfekt projekt för kursen skulle jag säga, där vi verkligen får arbeta med det vi har lärt oss under kursens gång.
                </p>
                <b>
                        <p>Avsluta med ett sista stycke med dina tankar om kursen.</p>
                    </b>
                    <p>Kursen har varit lärorik. Jag har lärt mig mycket med tanke på att jag aldrig hört talas om Docker tidigare.
                        De två guiderna (Bash och Docker) har varit centrala för kursen och de har hjälp mig mycket. Det kanske kan finnas fler exempel för Docker-compose i guiden, men i övrigt ser jag inga förbättringsmöjligheter.
                        Det enda som jag hade lite problem med, som ni kanske behöver gå igenom mer, var Regex. Framför allt labben som kändes väldigt mycket pang på. Kanske försöka dela upp det på två veckor i alla fall.

                        Men som sagt jag är nöjd med kursen och jag ger den 8 / 10 i betyg, jag hade absolut kunnat rekommendera kursern för mina vänner.
                    </p>


        </section>

    </article>



    <script type="text/javascript" src="js/main.js"></script>
</body>

</html>